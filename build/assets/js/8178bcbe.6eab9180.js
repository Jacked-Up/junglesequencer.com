"use strict";(self.webpackChunkjungle_website=self.webpackChunkjungle_website||[]).push([[3637],{5859:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>d,metadata:()=>s,toc:()=>a});var r=t(5893),o=t(1151);const d={title:"Concepts",sidebar_position:1,slug:"/concepts"},i=void 0,s={id:"documentation/concepts",title:"Concepts",description:"Jungle is a one-of-a-kind tool. There are many concepts and ideas that are unique to Jungle.",source:"@site/docs/documentation/concepts.mdx",sourceDirName:"documentation",slug:"/concepts",permalink:"/docs/concepts",draft:!1,unlisted:!1,editUrl:"https://github.com/Jacked-Up/junglesequencer.com/tree/prod/docs/documentation/concepts.mdx",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Concepts",sidebar_position:1,slug:"/concepts"},sidebar:"documentationSidebar",previous:{title:"Welcome",permalink:"/docs/"},next:{title:"Jungle Nodes",permalink:"/docs/category/jungle-nodes"}},l={},a=[{value:"Terms",id:"terms",level:2},{value:"Tree and Node Lifecycle",id:"tree-and-node-lifecycle",level:2},{value:"Tree Lifecycle",id:"tree-lifecycle",level:3},{value:"When a tree is started:",id:"when-a-tree-is-started",level:4},{value:"While the tree is running:",id:"while-the-tree-is-running",level:4},{value:"When a tree is stopped:",id:"when-a-tree-is-stopped",level:4},{value:"Node Lifecycle",id:"node-lifecycle",level:3},{value:"When a node is started:",id:"when-a-node-is-started",level:4},{value:"While a node is running:",id:"while-a-node-is-running",level:4},{value:"When a node is stopped:",id:"when-a-node-is-stopped",level:4},{value:"Port Calls",id:"port-calls",level:2},{value:"IO Node",id:"io-node",level:3},{value:"Branch Node",id:"branch-node",level:3},{value:"Event Node",id:"event-node",level:3},{value:"Identity Node",id:"identity-node",level:3}];function h(e){const n={admonition:"admonition",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.p,{children:"Jungle is a one-of-a-kind tool. There are many concepts and ideas that are unique to Jungle.\r\nThis page will help you understand core concepts and ideas that are essential to using Jungle."}),"\n",(0,r.jsx)(n.h2,{id:"terms",children:"Terms"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Tree"}),": A container that manages a collection of nodes and their connections."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Node"}),": A unit of behavior that can be added to a tree."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Port"}),": A point on a node that connects to other nodes to form a sequence."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Call"}),": A payload that is sent from the output port of a node to the input port of another node."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"tree-and-node-lifecycle",children:"Tree and Node Lifecycle"}),"\n",(0,r.jsx)(n.p,{children:"Both trees and nodes follow a lifecycle that is managed by the runtime.\r\nUnderstanding this lifecycle is essential to creating and managing trees and nodes."}),"\n",(0,r.jsx)(n.h3,{id:"tree-lifecycle",children:"Tree Lifecycle"}),"\n",(0,r.jsx)(n.h4,{id:"when-a-tree-is-started",children:"When a tree is started:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The tree registers itself with the runtime."}),"\n",(0,r.jsxs)(n.li,{children:["The tree starts all ",(0,r.jsx)(n.strong,{children:"event"})," nodes."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"while-the-tree-is-running",children:"While the tree is running:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The tree updates all actively running nodes."}),"\n",(0,r.jsx)(n.li,{children:"If there are no more actively running nodes, the tree stops automatically."}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"when-a-tree-is-stopped",children:"When a tree is stopped:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"The tree unregisters itself with the runtime."}),"\n",(0,r.jsx)(n.li,{children:"The tree calls all revert actions on all nodes (if any)"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,r.jsx)(n.h4,{id:"when-a-node-is-started",children:"When a node is started:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The runtime first calls the ",(0,r.jsx)(n.code,{children:"OnStart"})," method on the node."]}),"\n",(0,r.jsxs)(n.li,{children:["The runtime then immediately calls the ",(0,r.jsx)(n.code,{children:"OnUpdate"})," method on the node."]}),"\n"]}),"\n",(0,r.jsx)(n.admonition,{title:"NOTE",type:"tip",children:(0,r.jsxs)(n.p,{children:["If the ",(0,r.jsx)(n.code,{children:"Stop"})," or ",(0,r.jsx)(n.code,{children:"CallAndStop"})," method is called from the ",(0,r.jsx)(n.code,{children:"OnStart"})," method, the ",(0,r.jsx)(n.code,{children:"OnUpdate"})," and ",(0,r.jsx)(n.code,{children:"OnFixedUpdate"})," method\r\nwill not be called."]})}),"\n",(0,r.jsx)(n.h4,{id:"while-a-node-is-running",children:"While a node is running:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The runtime calls the ",(0,r.jsx)(n.code,{children:"OnUpdate"})," and ",(0,r.jsx)(n.code,{children:"OnFixedUpdate"})," methods on the node."]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"when-a-node-is-stopped",children:"When a node is stopped:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["The runtime calls the ",(0,r.jsx)(n.code,{children:"OnStop"})," method on the node."]}),"\n"]}),"\n",(0,r.jsxs)(n.p,{children:["Nodes can be stopped anywhere at anytime by invoking nodes ",(0,r.jsx)(n.code,{children:"Stop"})," or ",(0,r.jsx)(n.code,{children:"CallAndStop"})," methods. The ",(0,r.jsx)(n.code,{children:"Call"}),", ",(0,r.jsx)(n.code,{children:"Stop"}),", and\r\n",(0,r.jsx)(n.code,{children:"CallAndStop"})," methods must be called from within the node's script itself."]}),"\n",(0,r.jsx)(n.admonition,{title:"WARNING",type:"warning",children:(0,r.jsxs)(n.p,{children:["If you never call ",(0,r.jsx)(n.code,{children:"Stop"})," or ",(0,r.jsx)(n.code,{children:"CallAndStop"})," from within a node, the node will run indefinitely."]})}),"\n",(0,r.jsx)(n.h2,{id:"port-calls",children:"Port Calls"}),"\n",(0,r.jsxs)(n.p,{children:["Port calls are how nodes talk to each other. Nodes can call other nodes from their output ports. When either the\r\n",(0,r.jsx)(n.code,{children:"Call"})," or ",(0,r.jsx)(n.code,{children:"CallAndStop"})," method is invoked, a port call is made."]}),"\n",(0,r.jsxs)(n.p,{children:["The ",(0,r.jsx)(n.code,{children:"IONode"})," and ",(0,r.jsx)(n.code,{children:"BranchNode"})," are the only node variations where the ",(0,r.jsx)(n.code,{children:"OnStart"})," method has an ",(0,r.jsx)(n.code,{children:"inputValue"})," parameter.\r\nThis input value is the data from the port call."]}),"\n",(0,r.jsx)(n.p,{children:"Each node performs port calls slightly differently.\r\nBelow is a brief overview of how each node variation handles port calls."}),"\n",(0,r.jsx)(n.h3,{id:"io-node",children:"IO Node"}),"\n",(0,r.jsxs)(n.p,{children:["The IONode is just a simpler version of the BranchNode. Since the IONode only has a single output port, making developers\r\ncreate a port call every time was redundant. The IONode's ",(0,r.jsx)(n.code,{children:"Call"})," and ",(0,r.jsx)(n.code,{children:"CallAndStop"})," methods automatically create the port\r\ncalls for you, only requiring the developer to provide the data to send."]}),"\n",(0,r.jsxs)(n.p,{children:["For simplicity, the IONode's ",(0,r.jsx)(n.code,{children:"Call"})," and ",(0,r.jsx)(n.code,{children:"CallAndStop"})," methods only require the value/data to send to the next node."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"using Jungle;\r\n\r\n[IONode(\r\n    OutputPortType = typeof(int)\r\n)]\r\npublic class SquareRootNode : IONode<int>\r\n{\r\n    protected override void OnStart(int number)\r\n    {\r\n        // Calculate the square root of the inputted number.\r\n        int squareRoot = number * number;\r\n\r\n        // Call any connected nodes and output the square root.\r\n        CallAndStop(squareRoot);\r\n    }\r\n\r\n    protected override void OnUpdate() { }\r\n}\n"})}),"\n",(0,r.jsxs)(n.p,{children:["The example above shows an IONode that calculates the square root of the inputted number and then calls the square root.\r\nAny node connected to the output port of the ",(0,r.jsx)(n.code,{children:"SquareRootNode"})," will receive the square root value."]}),"\n",(0,r.jsxs)(n.p,{children:["As you can see, the ",(0,r.jsx)(n.code,{children:"CallAndStop"})," method only requires the value to send to the next node."]}),"\n",(0,r.jsx)(n.h3,{id:"branch-node",children:"Branch Node"}),"\n",(0,r.jsxs)(n.p,{children:["The BranchNode is slightly more complex than the IONode. The BranchNode has the ability to have multiple output ports.\r\nThis means that the developer must specify which port to call when invoking the ",(0,r.jsx)(n.code,{children:"Call"})," or ",(0,r.jsx)(n.code,{children:"CallAndStop"})," method."]}),"\n",(0,r.jsxs)(n.p,{children:["Unlike the IONode, the BranchNode's ",(0,r.jsx)(n.code,{children:"Call"})," and ",(0,r.jsx)(n.code,{children:"CallAndStop"})," methods require the port index and the value/data to send.\r\nThe port index is the index of the output port to call.\r\nThe first output port has an index of 0, the second output port has an index of 1, and so on."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:'using Jungle;\r\n\r\n[BranchNode(\r\n    OutputPortNames = new []{ "Even",            "Odd" },\r\n    OutputPortTypes = new []{ typeof(Port.None), typeof(Port.None) }\r\n)]\r\npublic class IsEvenOrOddNode : BranchNode<int>\r\n{\r\n    protected override void OnStart(int number)\r\n    {\r\n        // Check if the inputted number is even.\r\n        var isEven = number % 2 == 0;\r\n\r\n        if (isEven)\r\n        {\r\n            // If the number is even, call the first output port.\r\n            CallAndStop(new Port.Call(0, Nothing));\r\n        }\r\n        else\r\n        {\r\n            // If the number is odd, call the second output port.\r\n            CallAndStop(new Port.Call(1, Nothing));\r\n        }\r\n    }\r\n\r\n    protected override void OnUpdate() { }\r\n}\n'})}),"\n",(0,r.jsxs)(n.p,{children:["The example above shows a BranchNode that checks if the inputted number is even or odd and then calls the appropriate\r\noutput port. The ",(0,r.jsx)(n.code,{children:"IsEvenOrOddNode"})," has two output ports, one for even numbers and one for odd numbers."]}),"\n",(0,r.jsxs)(n.p,{children:["The output ports themselves are declared within the ",(0,r.jsx)(n.code,{children:"BranchNode"})," attribute.\r\nThe ",(0,r.jsx)(n.code,{children:"OutputPortNames"})," and ",(0,r.jsx)(n.code,{children:"OutputPortTypes"})," properties are arrays that define the names and types of the output ports.\r\nYou can define as many output ports as you need."]}),"\n",(0,r.jsx)(n.h3,{id:"event-node",children:"Event Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp"})}),"\n",(0,r.jsx)(n.h3,{id:"identity-node",children:"Identity Node"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-csharp",children:"using Jungle;\r\nusing UnityEngine;\r\n\r\npublic class WaitForTimeNode : IdentityNode\r\n{\r\n    [SerializeField]\r\n    private float duration = 2f;\r\n\r\n    private float _startTime;\r\n\r\n    protected override void OnStart()\r\n    {\r\n        _startTime = Time.time;\r\n    }\r\n\r\n    protected override void OnUpdate()\r\n    {\r\n        // Bail if the duration hasn't passed yet.\r\n        if (Time.time - _startTime < duration)\r\n            return;\r\n\r\n        // When the duration has passed, call the output port.\r\n        CallAndStop();\r\n    }\r\n}\n"})})]})}function c(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(h,{...e})}):h(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>s,a:()=>i});var r=t(7294);const o={},d=r.createContext(o);function i(e){const n=r.useContext(d);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),r.createElement(d.Provider,{value:n},e.children)}}}]);